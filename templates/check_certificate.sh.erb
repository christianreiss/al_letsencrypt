#! /bin/bash
# This file is managed by
#  ____  _   _ ____  ____  _____ _____
# |  _ \| | | |  _ \|  _ \| ____|_   _|
# | |_) | | | | |_) | |_) |  _|   | |
# |  __/| |_| |  __/|  __/| |___  | |
# |_|    \___/|_|   |_|   |_____| |_|
#
#      All changes will be overwritten

#
# Tiny configuration things.
#
OSL_BIN="/usr/bin/openssl"
NMAP_BIN="/usr/bin/nmap"
PID="$$"
warning_seconds=1209600 # 14 days
error_seconds=604800    # 7 days
EXIT='0'
REAL_EXIT='0'


#
# Logging and Error.
#
function error {
	if [ "${SERVER}" != "" ] ; then
		if [ "${SERVER}" == "${DOMAIN}" ] ; then
			echo "[Error] ${SERVER}: $*"
		else
			echo "[Error] ${SERVER}/${DOMAIN}: $*"
		fi
	else
		echo "$*"
	fi
  REAL_EXIT=2
  trap "rm -f ${LOCKFILE}; rm -r /tmp/${PID}-ssl.log 2>/dev/null ; exit ${REAL_EXIT}" INT TERM EXIT
  exit 2
}

function error_inline {
	if [ "${SERVER}" != "" ] ; then
		if [ "${SERVER}" == "${DOMAIN}" ] ; then
			echo "[Error] ${SERVER}: $*"
		else
			echo "[Error] ${SERVER}/${DOMAIN}: $*"
		fi
	else
		echo "$*"
	fi
}

function log {
	if [ "${SERVER}" != "" ] ; then
		if [ "${SERVER}" == "${DOMAIN}" ] ; then
			echo "[OK] ${SERVER}: $*"
		else
			echo "[OK] ${SERVER}/${DOMAIN}: $*"
		fi
	else
		echo "$*"
	fi
}


#
# Highest (worst) access code wins.
#
function raiseExit {
  if [ ${1} -gt ${REAL_EXIT} ]; then
    REAL_EXIT=$1
  fi
}


#
# Locking, in case of hangs.
#
function locking {
  LOCKFILE="/tmp/${PID}.lock"
  touch /tmp/${PID}-ssl.log
  # Check if the lockfile exists.
  if [ -e "${LOCKFILE}" ] ; then
    # it does exist. Check if the process is still running.
    PID="`cat ${LOCKFILE}`"
    if [ "`ps --no-heading -q ${PID} | wc -l`" != "0" ] ; then
      # it is. Don't touch anything, walk away slowly.
      error "Still running."
    else
      # it is not. Stale lockfile. Keep calm and remove the lockfile.
      rm ${LOCKFILE}
    fi
  fi
  # No lockfile present (anymore, stale would have been deleted)
  echo $BASHPID > ${LOCKFILE} || error "unable to create lockfile."
  # Remove lockfile on script exit.
  trap "rm -f ${LOCKFILE}; rm -r /tmp/${PID}-ssl.log 2>/dev/null ; exit ${REAL_EXIT}" INT TERM EXIT
}
locking


#
# Parse command line arguments
#
for i in "$@"; do
	case $i in
    -s=*|--server=*)
    SERVER=`echo $i | sed 's/[-a-zA-Z0-9]*=//'`
    ;;
    -d=*|--domain=*)
    DOMAIN=`echo $i | sed 's/[-a-zA-Z0-9]*=//'`
    ;;
    -p=*|--port=*)
    PORTS=`echo $i | sed 's/[-a-zA-Z0-9]*=//'`
    ;;
    *)
            # unknown option
    ;;
	esac
done


#
# Sanity checks
#
if [ "${DOMAIN}" == "" ] ; then
	error "I need a domain to connect to."
fi

if [ "${SERVER}" == "" ] ; then
	SERVER=${DOMAIN}
fi

host ${SERVER} >/dev/null 2>/dev/null
if [ "$?" != '0' ] ; then
  error "Unable to contact server."
fi

#
# Set port to default
#
if [ "${PORTS}" == "" ] ; then
	PORTS='443'
fi

if [ "${PORTS}" == "PLESK" ] ; then
	PORTS='25 443 465 587 992 995 8443'
fi

if [ "${PORTS}" == "ZIMBRA" ] ; then
	PORTS='25 443 465 587 993 995'
fi

for PORT in $PORTS ; do

#  echo "Server: ${SERVER}"
#  echo "Domain: ${DOMAIN}"
#  echo "Port  : ${PORT}"


  #
  # Handle Start-TLS
  #
  case ${PORT} in
    '21')
      TLS='-starttls ftp'
    ;;

    '25')
      TLS='-starttls smtp'
    ;;

    '587')
      TLS='-starttls smtp'
    ;;

    *)
      TLS=""
    ;;
  esac


  #
  # Port-Probe the port
  #
  if [ "$(${NMAP_BIN} -p${PORT} ${SERVER} | grep 'open' | wc -l)" == "1" ] ; then

    #
    # OpenSSL-connect and save the result in a text file.
    #
    ${OSL_BIN} s_client -connect ${SERVER}:${PORT} ${TLS} -servername ${DOMAIN} -status -verify_return_error -showcerts < /dev/null >> /tmp/${PID}-ssl.log 1>> /tmp/${PID}-ssl.log 2>> /tmp/${PID}-ssl.log
    cp /tmp/${PID}-ssl.log /tmp/ssl-${PORT}.log
  # cat /tmp/${PID}-ssl.log


    #
    # Check Certification Times
    #
    output=$(cat /tmp/${PID}-ssl.log | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | ${OSL_BIN} x509 -noout -subject -dates 2>/dev/null)

    if [ "$?" -ne 0 ]; then
      error_inline "No certificates found while connecting (Port ${PORT})?"
      raiseExit 2
    else

      start_date=$(echo $output | sed 's/.*notBefore=\(.*\).*not.*/\1/g')
      end_date=$(echo $output | sed 's/.*notAfter=\(.*\)$/\1/g')

      start_epoch=$(date +%s -d "$start_date")
      end_epoch=$(date +%s -d "$end_date")

      epoch_now=$(date +%s)

      if [ "$start_epoch" -gt "$epoch_now" ]; then
        error_inline "Certificate for ${TARGET} is not yet valid"
        raiseExit 2
      fi

      seconds_to_expire=$(($end_epoch - $epoch_now))
      days_to_expire=$(($seconds_to_expire / 86400))


      #
      # Check for possible verification error_inlines.
      #
      verify_error_inline="$(grep "verify error_inline:" /tmp/${PID}-ssl.log | awk -F':' ' { print $3 } ')"

      #
      # If found we can stop right there.
      #
      if [ "${verify_error_inline}" != "" ] ; then
        error_inline "${verify_error_inline} (Port ${PORT}), Expiration in $days_to_expire days."
        raiseExit 2
      fi


      #
      # Check for Trust Issues
      #
      trust_error_inline="$(grep "Verify return code:" /tmp/${PID}-ssl.log | awk -F':' ' { print $2 } ')"

      #
      # If found we can stop right there.
      #
      if [ "$(echo ${trust_error_inline} | grep -v '0 (ok)' | wc -l)" != "0" ] ; then
        error_inline "Trust chain issue: ${trust_error_inline} (Port ${PORT}), Expiration in $days_to_expire days."
        raiseExit 2
      else

        #
        # If we are here: all is well.
        #
        if [ "${seconds_to_expire}" -lt "${warning_seconds}" ]; then
          if [ "${seconds_to_expire}" -lt "${error_seconds}" ]; then
            # Below error_inline threshhold.
            error_inline "Certificate (Port ${PORT}) is OK, but expiration is imminent! (Expiration in ${days_to_expire} days.)"
            raiseExit 2
          else
            # Below warning threshhold.
            log "Certificate (Port ${PORT}) is OK, but will expire soon. (Expiration in ${days_to_expire} days.)"
            raiseExit 1
          fi
        else
          log "Certificate (Port ${PORT}) is OK, Expiration in $days_to_expire days."
            raiseExit 0
        fi
      fi
    fi

    test -e /tmp/${PID}-ssl.log && rm -f /tmp/${PID}-ssl.log
  fi
done

trap "rm -f ${LOCKFILE}; rm -r /tmp/${PID}-ssl.log 2>/dev/null ; exit ${REAL_EXIT}" INT TERM EXIT
exit ${REAL_EXIT}
